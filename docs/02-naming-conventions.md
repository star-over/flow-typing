# Глава 2: Соглашения по именованию типов

Этот документ устанавливает единые правила именования для типов и интерфейсов TypeScript в проекте. Соблюдение этих правил обязательно для поддержания чистоты, предсказуемости и читаемости кодовой базы.

## 2.1. Общие правила

1.  **Стиль `PascalCase`**: Все имена типов (`type`), интерфейсов (`interface`) и перечислений (`enum`) должны быть написаны в стиле `PascalCase`.
    
    ```typescript
    type SomeType = { ... };
    interface AnotherInterface { ... }
    enum ProcessingState { ... }
    ```

2.  **Описательность и отсутствие сокращений**: Имена должны быть полными, ясными и точно описывать сущность, которую они представляют. Следует избегать неоднозначных или неочевидных сокращений.
    
    *   **Хорошо:** `KeyboardLayout`, `StreamSymbol`, `PerformanceScore`.
    *   **Плохо:** `KbdLayout`, `StrSym`, `PerfScore`.

## 2.2. Типы-идентификаторы и объединения (Union Types)

Имя для типа, представляющего собой объединение строковых или числовых литералов (часто используемых как ID или перечисление состояний), должно быть в **единственном числе**. Такой тип описывает одно возможное значение из набора, а не весь набор.

**Примеры:**
```typescript
// Описывает ОДИН из возможных статусов нажатия
type KeyCapPressResult = 'NONE' | 'CORRECT' | 'ERROR';

// Описывает идентификатор ОДНОГО пальца
type FingerId = 'L5' | 'L4' | 'L3' | 'L2' | 'L1' | 'LB' | 'RB' | 'R1' | 'R2' | 'R3' | 'R4' | 'R5';

// Описывает ОДНУ из двух сторон руки
type HandSide = 'Left' | 'Right';
```

## 2.3. Типы-объекты (Object Types)

Имя для типа, описывающего структуру объекта, должно быть существительным в **единственном числе**. Оно представляет один экземпляр этой структуры.

**Примеры:**
```typescript
// Описывает ОДНУ физическую клавишу и ее геометрию
interface PhysicalKey {
  keyCapId: KeyCapId;
  unitWidth?: KeyCapUnitWidth;
};

// Описывает ОДИН символ в потоке упражнения
interface StreamSymbol {
  targetSymbol: string;
  targetKeyCaps: KeyCapId[];
  attempts: StreamAttempt[];
}
```
Следует избегать избыточных суффиксов, таких как `Item` или `Data` (`StreamItem`, `KeyData`), если имя само по себе уже достаточно ясно.

## 2.4. Типы-коллекции и макеты (Layouts)

Подход к именованию коллекций зависит от их структуры и семантического значения.

### Простой массив (`T[]`)

В большинстве случаев для описания простого массива элементов следует использовать конструкцию `T[]` напрямую, без создания отдельного псевдонима типа.

```typescript
// Хорошо: функция принимает массив символов
function processSymbols(symbols: StreamSymbol[]): void;

// Плохо: создание лишнего типа для простого массива
type StreamSymbolList = StreamSymbol[];
function processSymbols(symbols: StreamSymbolList): void;
```

### Сложная структура или концептуальная группа

Если коллекция представляет собой сложную структуру (например, `T[][]`) или является единой концептуальной сущностью (например, раскладка клавиатуры), ей следует дать уникальное описательное имя. Такое имя, как правило, должно быть в **единственном числе** и может иметь суффикс `Layout`, если оно описывает макет или раскладку.

**Примеры:**
```typescript
// Описывает всю физическую раскладку клавиатуры как единую сущность (массив рядов клавиш)
type KeyboardLayout = PhysicalKey[][];

// Описывает всю символьную раскладку как единую систему (массив сопоставлений)
type SymbolLayout = {
  symbol: string;
  keyCaps: KeyCapId[];
}[];
```
Здесь `KeyboardLayout` и `SymbolLayout` — это имена, описывающие целостную концепцию, а не просто "список".
