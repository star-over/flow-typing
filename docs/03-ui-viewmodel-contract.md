# Глава 3: Визуальный контракт UI (`HandsSceneViewModel`)

Этот документ является формальной спецификацией для объекта `HandsSceneViewModel` — структуры данных, которая служит "визуальным контрактом" между бизнес-логикой приложения (машинами состояний) и UI-компонентами (`HandsExt.tsx`).

**Основной принцип:** UI-компоненты должны быть максимально "глупыми". Их единственная задача — отрисовать `ViewModel` как есть, без каких-либо собственных вычислений или логики. Вся логика формирования визуального состояния инкапсулирована в `viewModel-builder.ts`.

## 3.1. Архитектурный паттерн: "ViewModel Pipeline"

Для обеспечения чистоты, тестируемости и расширяемости, `HandsSceneViewModel` создается с использованием паттерна **"Конвейер" (Pipeline)**.

1.  **Инициализация:** Процесс начинается с создания базовой, "пустой" модели, где все пальцы и клавиши находятся в состоянии по умолчанию (`getIdleViewModel()`).
2.  **Последовательные трансформации:** Исходная `ViewModel` последовательно передается через цепочку чистых функций-трансформеров. Каждая функция отвечает строго за один аспект визуального состояния (например, `applyTargetFingerStates` отвечает только за установку состояния пальцев, `applyNavigationPaths` — только за отрисовку пути).
3.  **Результат:** Финальная функция в цепочке возвращает полностью сформированную и готовую к отрисовке `ViewModel`.

Этот подход делает логику построения `ViewModel` декларативной и легко отслеживаемой.

## 3.2. Структура данных

#### `KeySceneState`
Полное визуальное состояние одной клавиши на сцене.
```typescript
interface KeySceneState {
  visibility: 'VISIBLE' | 'INVISIBLE';
  navigationRole: 'NONE' | 'PATH' | 'TARGET';
  navigationArrow: 'NONE' | 'UP' | 'DOWN' | 'LEFT' | 'RIGHT' | ...;
  pressResult: 'NONE' | 'CORRECT' | 'ERROR';
}
```

#### `HandsSceneViewModel`
Итоговая модель, представляющая собой словарь (`Record`), где ключ — это `FingerId`, а значение — состояние этого пальца и, опционально, состояния всех клавиш в его кластере.

```typescript
type HandsSceneViewModel = Record<FingerId, {
  fingerState: 'TARGET' | 'INACTIVE' | 'NONE' | 'ERROR';
  // Словарь состояний для всех клавиш в кластере этого пальца.
  // Определяется ТОЛЬКО для пальцев в состоянии 'TARGET'.
  keyCapStates?: Record<KeyCapId, KeySceneState>; 
}>;
```

## 3.3. Ключевые правила формирования ViewModel

Эти правила должны неукоснительно соблюдаться при построении `ViewModel`.

#### 1. Состояния пальцев (`fingerState`)
*   `TARGET`: Палец, который должен выполнить действие (нажать целевую клавишу или модификатор).
*   `ERROR`: Палец, который совершил ошибочное нажатие (нажал не "свою" клавишу, перепутав пальцы).
*   `INACTIVE`: "Соседний" палец на той же руке, где есть `TARGET` или `ERROR` палец. Его задача — быть на экране, но не привлекать внимания.
*   `NONE`: Любой палец на полностью неактивной руке.

#### 2. Правило "Активной Руки" (Active Hand Rule)
*   Если следующий ввод требует действия одной рукой, все пальцы на второй, "неактивной" руке должны иметь `fingerState: 'NONE'`. Это уменьшает визуальный шум и концентрирует внимание пользователя.
*   Если следующий ввод требует аккорда (например, `Shift + F`), обе руки считаются активными, и пальцы, не участвующие в аккорде, получают `fingerState: 'INACTIVE'`.

#### 3. Правило "Полного Кластера" (Complete Cluster Rule)
*   Словарь `keyCapStates` определяется **только для `TARGET` пальцев**. У пальцев в состоянии `INACTIVE`, `NONE` и `ERROR` это свойство должно отсутствовать.
*   Для каждого `TARGET` пальца, его `keyCapStates` должен содержать **полный набор** всех клавиш, за которые этот палец отвечает согласно `finger-layout-asdf.ts`. Это необходимо, чтобы UI мог построить целостную визуальную картину рабочего пространства пальца.

#### 4. Навигационные подсказки (`navigationRole` и `navigationArrow`)
*   `navigationRole: 'TARGET'`: Присваивается целевой клавише, которую нужно нажать.
*   `navigationRole: 'PATH'`: Присваивается клавишам, лежащим на траектории движения пальца от его домашней позиции до `TARGET`.
*   `navigationArrow`: Используется **только для клавиш с ролью `'PATH'`**. Указывает направление к следующей клавише на пути. Для всех остальных клавиш (`'TARGET'`, `'NONE'`) должна быть `'NONE'`.

#### 5. Результат нажатия (`pressResult`)
*   `'CORRECT'`: Клавиша была нажата правильно и вовремя.
*   `'ERROR'`: Клавиша была нажата ошибочно (не та клавиша, или в неправильное время, или с ненужным модификатором).
*   `'NONE'`: Клавиша не участвовала в последнем вводе.

## 3.4. Сценарии обработки ошибок (Примеры)

Логика `ViewModel` должна однозначно визуализировать любой тип ошибки, чтобы дать пользователю четкую обратную связь.

*   **Сценарий 1: Ошибка в пределах одного пальца** (Цель 'k', нажата 'i').
    *   `R3` (целевой палец): `fingerState: 'TARGET'`.
    *   В его `keyCapStates`:
        *   `KeyK` (цель): `navigationRole: 'TARGET'`.
        *   `KeyI` (ошибка): `pressResult: 'ERROR'`.

*   **Сценарий 2: Ошибка другим пальцем** (Цель 'k' (палец `R3`), нажата 'j' (палец `R2`)).
    *   `R3` (целевой палец): `fingerState: 'TARGET'`. Его кластер клавиш отображается, чтобы показать цель.
    *   `R2` (ошибочный палец): `fingerState: 'ERROR'`. Его кластер клавиш **не отображается**. Подсвечивается только сам палец.

*   **Сценарий 3: Ошибка с пропущенным модификатором** (Цель 'K' (Shift+k), нажата 'k').
    *   `L5` (для Shift): `fingerState: 'TARGET'`. В его `keyCapStates`, `ShiftLeft` имеет `pressResult: 'ERROR'`.
    *   `R3` (для 'k'): `fingerState: 'TARGET'`. В его `keyCapStates`, `KeyK` имеет `pressResult: 'CORRECT'` (так как сама клавиша верна).

*   **Сценарий 4: Ошибка с ненужным модификатором** (Цель 'k', нажато 'Shift+k').
    *   `R3` (для 'k'): `fingerState: 'TARGET'`. В его `keyCapStates`, `KeyK` имеет `pressResult: 'ERROR'`.
    *   `L5` (для Shift): `fingerState: 'ERROR'`.

Полный набор примеров состояний ViewModel для различных сценариев можно найти в файле `src/fixtures/hands-ext/test-data.ts`.
