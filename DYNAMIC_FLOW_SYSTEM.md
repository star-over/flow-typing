# Архитектура и реализация системы "Dynamic Flow"

Этот документ суммирует концептуальный и технический дизайн адаптивной системы управления уроками "Dynamic Flow".

## 1. Концепция "Обучение в потоке"

Система работает как интеллектуальный "термостат", цель которого — постоянно удерживать пользователя в **"зоне потока"** (Flow Zone). Это состояние, когда задача достаточно сложна, чтобы быть интересной и развивающей, но не настолько трудна, чтобы вызывать фрустрацию.

-   **Слишком легко? (`PS > 95%`)** → "Зона Скуки". Система повышает сложность.
-   **Слишком сложно? (`PS < 70%`)** → "Зона Фрустрации". Система понижает сложность.
-   **В самый раз? (`70% <= PS <= 95%`)** → "Зона Потока". Система закрепляет навык, не меняя сложность.

## 2. Ключевые архитектурные компоненты

-   **Вектор Сложности (Difficulty Vector - DV):** Многомерный объект, описывающий сложность задания (`{ complexity: float, length: int, focus: string[] }`), а не простое число.
-   **Показатель Производительности (Performance Score - PS):** Вычисляемая в реальном времени взвешенная оценка качества набора на коротком промежутке времени (последние 5-10 слов). Является главным драйвером для изменения сложности.
-   **Генератор Уроков и Корпус Текстов:** `Генератор` подбирает текст из `Корпуса` (базы данных упражнений), который соответствует текущему `Вектору Сложности`.

## 3. Подходы к технической реализации

### Подход 1: Frontend-Only (Рекомендован для MVP)

Вся логика, база упражнений и статистика пользователя живут в браузере.

-   **Стек:**
    -   **Хранение данных:** `IndexedDB` для корпуса упражнений и статистики пользователя.
    -   **Оркестрация:** `XState` (существующая `training.machine`) для управления циклом "ввод -> анализ -> коррекция -> подбор контента".
-   **Плюсы:**
    -   Полностью автономен, работает оффлайн.
    -   Нулевые затраты на сервер, высокая приватность данных.
    -   Идеально для быстрой реализации и проверки гипотез (соответствует духу MVP).
-   **Минусы:**
    -   Замедление первой загрузки из-за необходимости скачивания всего корпуса.
    -   Отсутствие синхронизации прогресса между устройствами.

### Подход 2: Гибридный Local-First (Рекомендован для Production)

Лучшее из двух миров: скорость локальной работы и мощь бэкенда.

-   **Стек:**
    -   **Клиент:** `IndexedDB` для кэширования "порций" упражнений, `XState` для логики.
    -   **Бэкенд:** Сервер (например, Node.js) с полноценной БД (например, PostgreSQL) для хранения основного корпуса и профилей пользователей.
    -   **Связь:** API для фоновой синхронизации статистики и подгрузки новых порций упражнений.
-   **Плюсы:**
    -   Мгновенная загрузка приложения.
    -   Надежная работа в оффлайн-режиме с локальными данными.
    -   "Бесконечный" корпус упражнений и кросс-девайсная синхронизация.
-   **Минусы:**
    -   Значительно более высокая сложность реализации (требуется разработка бэкенда и логики синхронизации).

## 4. Итеративная стратегия внедрения

1.  **Фаза 1 (MVP):** Реализовать **Frontend-Only** подход, чтобы быстро запустить и проверить ядро продукта.
2.  **Фаза 2 (Архитектура):** Инкапсулировать всю логику работы с данными в абстрактный "Репозиторий". Это позволит в будущем подменить источник данных без изменения основной логики.
3.  **Фаза 3 (Масштабирование):** Реализовать бэкенд и переключить "Репозиторий" на работу с API, осуществив плавный переход к **гибридной Local-First** модели.

## 5. Роль стейт-машин и инструментария

-   **Декомпозиция машин:** Настоятельно рекомендуется выделить логику расчета `Performance Score` в отдельную дочернюю стейт-машину (`performance.machine`), порождаемую из основной (`training.machine`). Это улучшит разделение ответственности, тестируемость и чистоту кода.
-   **Инструменты для работы с данными:** Для упрощения взаимодействия с `IndexedDB` и реализации "живых" запросов стоит рассмотреть использование библиотек-абстракций, таких как **TanStack DB** (с адаптером для RxDB или TrailBase), особенно при переходе к гибридной модели.
