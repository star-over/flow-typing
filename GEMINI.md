# Обзор проекта

Это приложение Next.js для тренировки слепой печати. Оно предоставляет визуальное представление клавиатуры и помогает пользователям изучить правильное расположение пальцев для каждой клавиши. Приложение создано с использованием TypeScript, React и Tailwind CSS. Оно использует Storybook для разработки компонентов и Vitest для тестирования.

## Ключевые особенности

*   **Визуальная клавиатура:** Визуальное представление клавиатуры, которое обеспечивает обратную связь при нажатии клавиш.
*   **Зоны пальцев:** Подсветка правильного пальца для каждой клавиши.
*   **Практика печати:** Пользователи могут практиковаться в печати и получать обратную связь о своей точности.

# Сборка и запуск

## Разработка

Чтобы запустить сервер для разработки, используйте следующую команду:

```bash
npm run dev
```

Это запустит сервер разработки Next.js по адресу `http://localhost:3000`.

## Storybook

Чтобы запустить Storybook, используйте следующую команду:

```bash
npm run storybook
```

Это запустит сервер разработки Storybook по адресу `http://localhost:6006`.

## Сборка

Чтобы собрать приложение для продакшена, используйте следующую команду:

```bash
npm run build
```

Это создаст готовую к продакшену сборку в каталоге `.next`.

## Тестирование

Чтобы запустить тесты, используйте следующую команду:

```bash
npm run test
```

Это запустит тесты с использованием Vitest.

# Соглашения по разработке

## Стиль кода

В проекте используется стандартный стиль кода Next.js с ESLint для линтинга. Конфигурацию можно найти в `eslint.config.mjs`.

## Соглашения по именованию

В проекте принята формализованная система именования типов. Подробные правила описаны в файле [NAMING_CONVENTIONS.md](./NAMING_CONVENTIONS.md).

## Компоненты

Компоненты находятся в каталоге `src/components`. Компоненты пользовательского интерфейса находятся в `src/components/ui`. В проекте используется `class-variance-authority` для создания вариантов компонентов.

## Данные

Данные приложения находятся в каталоге `src/data`. Сюда входят раскладки клавиатуры, зоны пальцев и раскладки символов.

*   **`symbol-layout-en-qwerty.ts`**: Определяет символы для каждой клавиши (`keyCapId`) с учетом модификатора `Shift`. Использует тип `SymbolLayout`. Логика обработки предусматривает фолбэк на не-Shift версию для системных клавиш.
*   **`finger-layout-asdf.ts`**: Сопоставляет каждую клавишу (`keyCapId`) с идентификатором пальца (`fingerId`), ответственного за ее нажатие. Использует тип `FingerLayout`.
*   **`keyboard-layout-ansi.ts`**: Описывает физическую структуру клавиатуры, включая расположение клавиш по рядам, их размеры и базовые визуальные свойства. Использует тип `KeyboardLayout`.

## Алгоритм определения навигационных статусов клавиш

Для интерактивного обучения в приложении используется система навигационных статусов (`navigationRole`), которая визуально подсказывает пользователю, куда двигать палец. Статусы определяются динамически для каждого целевого символа (`targetSymbol`).

Ключевые статусы:
- **`HOME`**: Исходная ("домашняя") клавиша для пальца, который должен нажать целевую клавишу.
- **`TARGET`**: Целевая клавиша, которую необходимо нажать.
- **`PATH`**: Промежуточные клавиши, образующие путь от `HOME` до `TARGET`.
- **`IDLE`**: Все остальные клавиши.

### Логика определения статусов

1.  **Определение `TARGET` и `HOME`:**
    -   По `targetSymbol` находится `keyCapId` целевой клавиши (из `symbol-layout-en-qwerty.ts`). Этой клавише присваивается статус `TARGET`.
    -   По `keyCapId` целевой клавиши определяется ответственный палец `fingerId` (из `finger-layout-asdf.ts`).
    -   Для этого `fingerId` находится его "домашняя" клавиша (с флагом `isHomeKey: true`). Этой клавише присваивается статус `HOME`.

2.  **Определение `PATH`:**
    Алгоритм строит путь, состоящий из двух отрезков: вертикального и горизонтального.
    -   Сначала определяются координаты (`rowIndex`, `colIndex`) для `HOME` и `TARGET` клавиш в матрице `keyboard-layout-ansi.ts`.
    -   **Вертикальный отрезок:** Собираются все клавиши, находящиеся в том же столбце, что и `HOME` клавиша, на строках между `HOME` и `TARGET`.
    -   **Горизонтальный отрезок:** Собираются все клавиши, находящиеся в той же строке, что и `TARGET` клавиша, на столбцах между `HOME` и `TARGET`.
    -   Клавишам, попавшим в эти отрезки (кроме самих `HOME` и `TARGET`), присваивается статус `PATH`.

### Пример: `targetSymbol = '5'`

1.  **`TARGET`**: Символу `'5'` соответствует `keyCapId: "Digit5"`. Клавиша **`Digit5`** получает статус `TARGET`.
2.  **`HOME`**: За клавишу `Digit5` отвечает палец `L2` (левый указательный). Его домашняя клавиша — **`KeyF`**. Она получает статус `HOME`.
3.  **`PATH`**:
    -   Координаты `KeyF` (HOME): `rowIndex: 2`, `colIndex: 4`.
    -   Координаты `Digit5` (TARGET): `rowIndex: 0`, `colIndex: 5`.
    -   **Вертикальный путь** (по столбцу `4` от строки `2` до `0`): `KeyF` -> `KeyR` -> `Digit4`.
    -   **Горизонтальный путь** (по строке `0` от столбца `4` до `5`): `Digit4` -> `Digit5`.
    -   Объединяем и исключаем `HOME` и `TARGET`: остаются **`KeyR`** и **`Digit4`**. Они получают статус `PATH`.
4.  **`IDLE`**: Все остальные клавиши (например, `KeyT`, `KeyG`, которые тоже относятся к пальцу `L2`, но не лежат на пути) получают статус `IDLE`.

Эта логика реализована в функции `findPath` в файле `src/lib/virtual-layout.ts`.

## Типы

Типы TypeScript находятся в каталоге `src/interfaces`.

# Сохранение информации

Если потребуется сохранить информацию - не использовать внутренний механизм сохранения, так как в этом случае данные сохраняются в общий файл, к которому имеют доступ все проекты, и тогда информация из одного проекта перетечет в другой. Для сохранения информации о проекте необходимо целенаправленно модифицировать именно этот файл.

# Рекомендации по взаимодействию ИИ

## Стиль общения

*   **Деловой и нейтральный тон:** Общение должно быть деловым, без эмоциональной окраски. Следует избегать извинений, обещаний, чрезмерной вежливости или других эмоциональных выражений.
*   **Обоснованность утверждений:** Избегать безосновательной уверенности в правильности предложенных решений до их фактической проверки. Признавать итеративный характер процесса разработки и возможность необходимости корректировок.