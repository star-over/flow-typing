# Обзор проекта

Это приложение Next.js для тренировки слепой печати **FlowTyping**.

**Философия проекта:** `FlowTyping` основан на идее **"рефлексивно-адаптивного обучения"**. Вместо скучного заучивания расположения клавиш, в основе лежит формирование мышечной памяти и рефлексов. Обучение происходит через практику на реальных словах и предложениях, а не на бессмысленных наборах символов.

Приложение создано с использованием TypeScript, React и Tailwind CSS. Оно использует Storybook для разработки компонентов и Vitest для тестирования.

## Ключевые особенности

### Визуализация движения
Ключевая инновация проекта — отказ от традиционной виртуальной клавиатуры в пользу **"визуализации движения"**. Этот механизм показывает пользователю путь, который должен проделать палец от исходной позиции до целевой клавиши и обратно.

*   **Контекстный фокус:** На экране отображается только та рука и палец, которые должны совершить действие.
*   **Блок клавиш:** Вместо всей клавиатуры показывается только небольшой блок клавиш, доступный для активного пальца.
*   **Карта движения:** Внутри блока статично подсвечиваются два типа клавиш для наглядности:
    *   `TARGET`: Целевая клавиша, которую нужно нажать.
    *   `PATH`: Клавиши, лежащие на пути движения пальца к `TARGET`.
*   **Обратная связь:** Система дает немедленную цветовую обратную связь о правильности нажатия, помогая корректировать движение в кодировке «рука-палец-движение».

### Адаптивное обучение
Интеллектуальный алгоритм подбирает упражнения (фразы), акцентируя внимание на символах и комбинациях, с которыми у пользователя возникают трудности.

*   **Приоритет точности:** Алгоритм не повышает сложность, пока пользователь не достигнет высокого порога точности (например, 98%).
*   **Расчет сложности:** Сложность упражнений рассчитывается на основе нескольких факторов: сложности символа (путь до клавиши), сложности пальца (мизинец/безымянный), а также средней и максимальной сложности слов во фразе.
*   **Источник текстов:** Упражнения генерируются из реальных слов и предложений.

### Строка потока (`FlowLine`)
Интерактивная "бегущая строка", визуализирующая поток символов для набора (`Stream`) и имитирующая движение каретки печатной машинки. Она отображает:
*   **Pending Symbols:** Символы, которые предстоит набрать.
*   **Completed Symbols:** Уже набранные символы, подсвеченные в зависимости от статуса (правильно с первой попытки, исправлено, неверно).

## Долгосрочное видение

Развитие проекта разделено на 4 фазы:
1.  **Фаза 1 (MVP):** Проверка гипотезы об эффективности "визуализации движения".
2.  **Фаза 2 (Product/Market Fit):** Итеративное улучшение продукта и рост пользовательской базы.
3.  **Фаза 3 (Монетизация):** Внедрение Freemium и B2B моделей.
4.  **Фаза 4 (Лидерство):** Становление лидером рынка.

# Технологический стек MVP

*   **Фронтенд:** React (Next.js) с TypeScript.
*   **Стилизация:** Tailwind CSS.
*   **UI-компоненты:** `shadcn/ui` (на основе Radix UI).
*   **Тестирование:** Vitest.
*   **База данных (клиент):** `localStorage`. **Серверная БД в MVP не используется.**
*   **Управление состоянием:** Zustand.
*   **Интернационализация (i18n):** `next-i18next`.
*   **Управление состоянием через URL:** Некоторые состояния (язык, раскладка) управляются через URL query parameters.

# Ограничения MVP (Out of Scope)

Следующие функции **не будут** реализованы в рамках MVP:
*   Полноценный личный кабинет с историей тренировок.
*   Геймификация (достижения, уровни, рейтинги).
*   Обучающий раздел по эргономике.
*   Визуализация и оценка ритма.
*   **Анимация движения пальцев или пути.**
*   Поддержка более двух языков (Английский QWERTY, Русский ЙЦУКЕН).
*   Специализированные уроки.
*   Рекламная и Freemium модели.

# Сборка и запуск

## Разработка
`npm run dev`
Запускает сервер разработки Next.js по адресу `http://localhost:3000`.

## Storybook
`npm run storybook`
Запускает сервер разработки Storybook по адресу `http://localhost:6006`.

## Сборка
`npm run build`
Создает готовую к продакшену сборку в каталоге `.next`.

## Тестирование
`npm run test`
Запускает тесты с использованием Vitest.

# Соглашения по разработке

## Стиль кода и именование
В проекте используется стандартный стиль кода Next.js с ESLint (`eslint.config.mjs`) и формализованная система именования типов (см. `NAMING_CONVENTIONS.md`).

## Компоненты и данные
*   **Компоненты:** Находятся в `src/components`. UI-компоненты (`src/components/ui`) используют `class-variance-authority`.
*   **Данные:** Раскладки клавиатуры, зоны пальцев и символов находятся в `src/data`.

## Типы
Типы TypeScript находятся в `src/interfaces`.

## Сохранение информации

Если потребуется сохранить информацию - не использовать внутренний механизм сохранения, так как в этом случае данные сохраняются в общий файл, к которому имеют доступ все проекты, и тогда информация из одного проекта перетечет в другой. Для сохранения информации о проекте необходимо целенаправленно модифицировать именно этот файл.

# Архитектура машин состояний (XState)

## Паттерн общения "Родитель-Потомок"

В проекте используется паттерн, при котором дочерняя машина состояний (child) отправляет события родительской (parent). Для обеспечения строгой типизации и избежания циклических зависимостей принят следующий подход:

1.  **Явная передача родителя:** Родительская машина при вызове дочерней (`invoke`) явно передает ссылку на свой актор (`self`) через `input`.

    *   **Пример в родительской машине (`app.machine.ts`):**
        ```typescript
        invoke: {
          id: 'keyboardService',
          src: keyboardMachine,
          input: ({ self }) => ({ parentActor: self }),
        }
        ```

2.  **Получение в дочерней машине:** Дочерняя машина получает ссылку на родителя через `input` и сохраняет ее в своем контексте.

    *   **Пример в дочерней машине (`keyboard.machine.ts`):**
        ```typescript
        context: ({ input }) => ({
          // ...
          parentActor: input.parentActor,
        }),
        ```

3.  **Отправка события родителю:** Для отправки события используется действие `sendTo` с указанием сохраненной в контексте ссылки на родителя.

    *   **Пример в дочерней машине (`keyboard.machine.ts`):**
        ```typescript
        recognizePressedKeys: sendTo(
          ({ context }) => context.parentActor,
          // ...
        )
        ```

Этот подход обеспечивает надежную и типизированную связь между машинами состояний.

## Архитектура UI и ViewModel

Для обеспечения чистоты архитектуры и разделения ответственности между логикой и представлением, в проекте используется концепция "ViewModel".

- **ViewModel для сцены рук:** `HandsSceneViewModel` является "контрактом" данных для компонента `HandsExt.tsx`.
- **Подробное описание:** Вся структура `HandsSceneViewModel`, правила ее формирования и примеры состояний задокументированы в файле **`VisualContract.md`**.

# Требования к взаимодействию с ИИ

## Стиль общения

*   **Строго деловой и нейтральный тон:** Общение ведется в строго деловом ключе, без эмоциональной окраски. **Запрещены** извинения, обещания, личные мнения, чрезмерная вежливость и другие формы эмоциональных выражений.
*   **Обоснованность утверждений:** Избегать безосновательной уверенности в правильности предложенных решений до их фактической проверки. Признавать итеративный характер процесса разработки и возможность необходимости корректировок.

### Проверка и Валидация

*   **Приоритет автоматизированных проверок:** При выполнении задач, связанных с анализом или модификацией кода, необходимо в первую очередь использовать автоматизированные средства проверки (`npm run test`). Этот подход является основным инструментом для выявления синтаксических ошибок, проблем с типами и регрессий, и ему следует отдавать предпочтение перед исключительно визуальным анализом кода.
*   **Обязательная верификация после изменений:** После каждого изменения кода, внесенного мной, я буду запускать команды `npm run type-check` и `npm run lint`. Задача будет считаться выполненной только после успешного выполнения обеих команд без ошибок.

## Работа с XState v5

В проекте используется **XState v5**. Весь новый код, связанный с машинами состояний, должен соответствовать синтаксису и практикам этой версии.

*   **Строгая типизация (`schemas`):** Используйте `schemas` для `context`, `events`, `actions`, `guards`.
*   **Обновление контекста (`assign`):** Действие `assign` должно возвращать объект с обновляемыми полями. Аргументы передаются в одном объекте: `{ context, event }`.
*   **Условия (Guards):** Используйте `guard` вместо `cond`.
*   **Передача данных в машину (`input`):** Используйте опцию `input` при запуске актора (`createActor`).
*   **Читаемость:** Давайте состояниям и событиям осмысленные имена. Используйте "переходные состояния" (`always`).
*   **Явное сужение типов событий:** Всегда используйте явные проверки-гарды (например, `if (event.type === '...')`) внутри действий (`actions`) и условий (`guards`) для корректного сужения типа `event`.

## Концепция рабочего процесса (из workflow.pdf)

Визуальный концепт из `docs/workflow.pdf` иллюстрирует путь пользователя при наборе слова "Home", демонстрируя ключевые механики интерфейса.

1.  **Наведение и указание цели:**
    *   В верхней строке (`FlowLine`) отображается слово для набора.
    *   Для каждого целевого символа, приложение подсвечивает активную руку и палец, который должен совершить действие. Неактивная рука "затухает".
    *   Вместо полной клавиатуры отображается только контекстный блок клавиш, доступный для активного пальца.
    *   Стрелка наглядно показывает траекторию движения пальца от его "домашней" клавиши до целевой.

2.  **Обработка заглавных букв:**
    *   При необходимости набора заглавной буквы (например, 'H'), интерфейс дополнительно показывает нажатие клавиши `Shift` мизинцем противоположной руки.

3.  **Многоуровневая обратная связь при ошибках:**
    *   **Неправильная клавиша (в зоне того же пальца):** Если пользователь нажимает не ту клавишу, но она находится в зоне ответственности того же пальца (например, цель 'm', набрано 'n'), то в `FlowLine` появляется индикация ошибки, а в блоке клавиш целевая клавиша ('m') остается подсвеченной как цель, а ошибочно нажатая ('n') подсвечивается как ошибка (например, красным).
    *   **Неправильная клавиша (в зоне другого пальца):** Система не может физически отследить палец, но она может определить, какой палец *должен был* нажать ошибочную клавишу согласно схеме `FingerLayout`. Например, если цель 'e' (средний палец), а пользователь нажимает 'w' (клавиша безымянного пальца):
        *   Система подсвечивает **правильный палец** (средний) как активная цель - target.
        *   Одновременно она подсвечивает **палец, ассоциированный с ошибкой** (безымянный), как ошибочное движение - INCORRECT.
        *   Это дает пользователю четкую обратную связь о том, что он ошибся не только клавишей, но и положением руки/пальца.

4.  **Завершение:**
    *   После успешного набора слова упражнение считается завершенным, что на схеме обозначено состоянием "pause". Обе руки "затухают", отображается старистика завершенного урока.
