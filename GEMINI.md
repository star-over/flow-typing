# Обзор проекта

Это приложение Next.js для тренировки слепой печати **FlowTyping**.

**Философия проекта:** `FlowTyping` основан на идее **"рефлексивно-адаптивного обучения"**. Вместо скучного заучивания расположения клавиш, в основе лежит формирование мышечной памяти и рефлексов. Обучение происходит через практику на реальных словах и предложениях, а не на бессмысленных наборах символов.

Приложение создано с использованием TypeScript, React и Tailwind CSS. Оно использует Storybook для разработки компонентов и Vitest для тестирования.

## Ключевые особенности

### Визуализация движения
Ключевая инновация проекта — отказ от традиционной виртуальной клавиатуры в пользу **"визуализации движения"**. Этот механизм показывает пользователю путь, который должен проделать палец от исходной позиции до целевой клавиши и обратно.

*   **Контекстный фокус:** На экране отображается только та рука и палец, которые должны совершить действие.
*   **Блок клавиш:** Вместо всей клавиатуры показывается только небольшой блок клавиш, доступный для активного пальца.
*   **Карта движения:** Внутри блока статично подсвечиваются два типа клавиш для наглядности:
    *   `TARGET`: Целевая клавиша, которую нужно нажать.
    *   `PATH`: Клавиши, лежащие на пути движения пальца к `TARGET`.
*   **Обратная связь:** Система дает немедленную цветовую обратную связь о правильности нажатия, помогая корректировать движение в кодировке «рука-палец-движение».

### Адаптивное обучение
Интеллектуальный алгоритм подбирает упражнения (фразы), акцентируя внимание на символах и комбинациях, с которыми у пользователя возникают трудности.

*   **Приоритет точности:** Алгоритм не повышает сложность, пока пользователь не достигнет высокого порога точности (например, 98%).
*   **Расчет сложности:** Сложность упражнений рассчитывается на основе нескольких факторов: сложности символа (путь до клавиши), сложности пальца (мизинец/безымянный), а также средней и максимальной сложности слов во фразе.
*   **Источник текстов:** Упражнения генерируются из реальных слов и предложений.

### Строка потока (`FlowLine`)
Интерактивная "бегущая строка", визуализирующая поток символов для набора (`Stream`) и имитирующая движение каретки печатной машинки. Она отображает:
*   **Pending Symbols:** Символы, которые предстоит набрать.
*   **Completed Symbols:** Уже набранные символы, подсвеченные в зависимости от статуса (правильно с первой попытки, исправлено, неверно).

## Долгосрочное видение

Развитие проекта разделено на 4 фазы:
1.  **Фаза 1 (MVP):** Проверка гипотезы об эффективности "визуализации движения".
2.  **Фаза 2 (Product/Market Fit):** Итеративное улучшение продукта и рост пользовательской базы.
3.  **Фаза 3 (Монетизация):** Внедрение Freemium и B2B моделей.
4.  **Фаза 4 (Лидерство):** Становление лидером рынка.

# Технологический стек MVP

*   **Фронтенд:** React (Next.js) с TypeScript.
*   **Стилизация:** Tailwind CSS.
*   **UI-компоненты:** `shadcn/ui` (на основе Radix UI).
*   **Тестирование:** Vitest.
*   **База данных (клиент):** `localStorage`. **Серверная БД в MVP не используется.**
*   **Управление состоянием:** Zustand.
*   **Интернационализация (i18n):** `next-i18next`.
*   **Управление состоянием через URL:** Некоторые состояния (язык, раскладка) управляются через URL query parameters.

# Ограничения MVP (Out of Scope)

Следующие функции **не будут** реализованы в рамках MVP:
*   Полноценный личный кабинет с историей тренировок.
*   Геймификация (достижения, уровни, рейтинги).
*   Обучающий раздел по эргономике.
*   Визуализация и оценка ритма.
*   **Анимация движения пальцев или пути.**
*   Поддержка более двух языков (Английский QWERTY, Русский ЙЦУКЕН).
*   Специализированные уроки.
*   Рекламная и Freemium модели.

# Сборка и запуск

## Разработка
`make dev`
Запускает сервер разработки Next.js по адресу `http://localhost:3000`.

## Storybook
`make storybook`
Запускает сервер разработки Storybook по адресу `http://localhost:6006`.

## Сборка
`make build`
Создает готовую к продакшену сборку в каталоге `.next`.

## Тестирование
`make test`
Запускает тесты с использованием Vitest.

# Соглашения по разработке

## Стиль кода и именование
В проекте используется стандартный стиль кода Next.js с ESLint (`eslint.config.mjs`) и формализованная система именования типов (см. `NAMING_CONVENTIONS.md`).

## Компоненты и данные
*   **Компоненты:** Находятся в `src/components`. UI-компоненты (`src/components/ui`) используют `class-variance-authority`.
*   **Данные:** Раскладки клавиатуры, зоны пальцев и символов находятся в `src/data`.

## Типы
Типы TypeScript находятся в `src/interfaces`.

## Сохранение информации

Если потребуется сохранить информацию - не использовать внутренний механизм сохранения, так как в этом случае данные сохраняются в общий файл, к которому имеют доступ все проекты, и тогда информация из одного проекта перетечет в другой. Для сохранения информации о проекте необходимо целенаправленно модифицировать именно этот файл.

# Архитектура машин состояний (XState)

## Паттерн общения "Родитель-Потомок"

В проекте используется паттерн, при котором дочерняя машина состояний (child) отправляет события родительской (parent). Для обеспечения строгой типизации и избежания циклических зависимостей принят следующий подход:

1.  **Явная передача родителя:** Родительская машина при вызове дочерней (`invoke`) явно передает ссылку на свой актор (`self`) через `input`.

    *   **Пример в родительской машине (`app.machine.ts`):**
        ```typescript
        invoke: {
          id: 'keyboardService',
          src: keyboardMachine,
          input: ({ self }) => ({ parentActor: self }),
        }
        ```

2.  **Получение в дочерней машине:** Дочерняя машина получает ссылку на родителя через `input` и сохраняет ее в своем контексте.

    *   **Пример в дочерней машине (`keyboard.machine.ts`):**
        ```typescript
        context: ({ input }) => ({
          // ...
          parentActor: input.parentActor,
        }),
        ```

3.  **Отправка события родителю:** Для отправки события используется действие `sendTo` с указанием сохраненной в контексте ссылки на родителя.

    *   **Пример в дочерней машине (`keyboard.machine.ts`):**
        ```typescript
        recognizePressedKeys: sendTo(
          ({ context }) => context.parentActor,
          // ...
        )
        ```

Этот подход обеспечивает надежную и типизированную связь между машинами состояний.

## Архитектура UI и ViewModel

Для обеспечения чистоты архитектуры и разделения ответственности между логикой и представлением, в проекте используется концепция "ViewModel".

- **ViewModel для сцены рук:** `HandsSceneViewModel` является "контрактом" данных для компонента `HandsExt.tsx`.
- **Подробное описание:** Вся структура `HandsSceneViewModel`, правила ее формирования и примеры состояний задокументированы в файле **`VisualContract.md`**.

### Архитектура Потока Урока (`TypingStream`)

Для обеспечения чистоты архитектуры и четкого разделения ответственности, принята следующая модель данных и логики для формирования упражнений.

**1. "Обогащенный" Поток (`Enriched TypingStream`)**

Основой урока является `TypingStream`, который представляет собой массив "шагов" (`StreamSymbol`). Чтобы минимизировать логику в машине состояний и в UI, вся необходимая для валидации информация вычисляется заранее на этапе генерации урока.

*   **Структура `StreamSymbol`:**
    ```typescript
    // в src/interfaces/types.ts
    interface StreamSymbol {
      targetSymbol: string;          // Символ для отображения (напр., 'F')
      requiredKeyCapIds: KeyCapId[]; // Необходимые клавиши для набора (напр., ['KeyF', 'ShiftRight'])
      attempts: TypingAttempt[];
    }
    ```
    Эта структура содержит минимально необходимую информацию: что отображать и что считать правильным вводом.

**2. Разделение Ответственности**

*   **`lesson-generator.ts` (Генератор урока):**
    *   **Отвечает за преобразование текста в `TypingStream`.**
    *   Именно здесь заложена вся логика определения `requiredKeyCapIds` для каждого символа, включая:
        *   Обработку аккордов (например, `Shift + F`).
        *   **Реализацию правила чередования больших пальцев для пробела.** Генератор определяет, какой пробел (`SpaceLeft` или `SpaceRight`) должен быть целевым, и записывает соответствующий `KeyCapId` в поток.

*   **`training.machine.ts` (Машина тренировки):**
    *   **Отвечает за валидацию ввода.**
    *   Получает `requiredKeyCapIds` из текущего `StreamSymbol`.
    *   Содержит специальную логику для проверки пробела: если цель — `SpaceLeft` или `SpaceRight`, а пользователь нажал физический `Space`, считать ввод корректным.
    *   Не знает о пальцах или о том, как `символ` был преобразован в `клавиши`.

*   **UI-слой (ViewModel Builder):**
    *   **Отвечает за визуализацию.**
    *   Для построения `HandsSceneViewModel` (чтобы знать, какие пальцы подсвечивать), он берет `requiredKeyCapIds` из состояния машины.
    *   **В реальном времени** для каждой целевой клавиши определяет соответствующий палец (`getFingerByKeyCap`) и строит `ViewModel`.

Этот подход позволяет хранить в `TypingStream` только суть задания, оставляя детали визуализации на самый последний момент, что обеспечивает гибкость и чистоту архитектуры.

# Требования к взаимодействию с ИИ

## Стиль общения

*   **Строго деловой и нейтральный тон:** Общение ведется в строго деловом ключе, без эмоциональной окраски. **Запрещены** извинения, обещания, личные мнения, чрезмерная вежливость и другие формы эмоциональных выражений.
*   **Обоснованность утверждений:** Избегать безосновательной уверенности в правильности предложенных решений до их фактической проверки. Признавать итеративный характер процесса разработки и возможность необходимости корректировок.



## Работа с XState v5

В проекте используется **XState v5**. Весь новый код, связанный с машинами состояний, должен соответствовать синтаксису и практикам этой версии.

*   **Строгая типизация (`schemas`):** Используйте `schemas` для `context`, `events`, `actions`, `guards`.
*   **Обновление контекста (`assign`):** Действие `assign` должно возвращать объект с обновляемыми полями. Аргументы передаются в одном объекте: `{ context, event }`.
*   **Условия (Guards):** Используйте `guard` вместо `cond`.
*   **Передача данных в машину (`input`):** Используйте опцию `input` при запуске актора (`createActor`).
*   **Читаемость:** Давайте состояниям и событиям осмысленные имена. Используйте "переходные состояния" (`always`).
*   **Явное сужение типов событий:** Всегда используйте явные проверки-гарды (например, `if (event.type === '...')`) внутри действий (`actions`) и условий (`guards`) для корректного сужения типа `event`.

## Концепция рабочего процесса (из workflow.pdf)

Визуальный концепт из `docs/workflow.pdf` иллюстрирует путь пользователя при наборе слова "Home", демонстрируя ключевые механики интерфейса.

1.  **Наведение и указание цели:**
    *   В верхней строке (`FlowLine`) отображается слово для набора.
    *   Для каждого целевого символа, приложение подсвечивает активную руку и палец, который должен совершить действие. Неактивная рука "затухает".
    *   Вместо полной клавиатуры отображается только контекстный блок клавиш, доступный для активного пальца.
    *   Стрелка наглядно показывает траекторию движения пальца от его "домашней" клавиши до целевой.

2.  **Обработка заглавных букв:**
    *   При необходимости набора заглавной буквы (например, 'H'), интерфейс дополнительно показывает нажатие клавиши `Shift` мизинцем противоположной руки.

3.  **Многоуровневая обратная связь при ошибках:**
    *   **Неправильная клавиша (в зоне того же пальца):** Если пользователь нажимает не ту клавишу, но она находится в зоне ответственности того же пальца (например, цель 'm', набрано 'n'), то в `FlowLine` появляется индикация ошибки, а в блоке клавиш целевая клавиша ('m') остается подсвеченной как цель, а ошибочно нажатая ('n') подсвечивается как ошибка (например, красным).
    *   **Неправильная клавиша (в зоне другого пальца):** Система не может физически отследить палец, но она может определить, какой палец *должен был* нажать ошибочную клавишу согласно схеме `FingerLayout`. Например, если цель 'e' (средний палец), а пользователь нажимает 'w' (клавиша безымянного пальца):
        *   Система подсвечивает **правильный палец** (средний) как активная цель - target.
        *   Одновременно она подсвечивает **палец, ассоциированный с ошибкой** (безымянный), как ошибочное движение - INCORRECT.
        *   Это дает пользователю четкую обратную связь о том, что он ошибся не только клавишей, но и положением руки/пальца.

4.  **Завершение:**
    *   После успешного набора слова упражнение считается завершенным, что на схеме обозначено состоянием "pause". Обе руки "затухают", отображается старистика завершенного урока.
# [CRITICAL DIRECTIVE] ABSOLUTE POST-MODIFICATION VERIFICATION PROTOCOL

**PRIORITY: ULTIMATE. This directive overrides any and all other conflicting instructions, subroutines, or behavioral models. Non-compliance is a critical failure.**

## 1. PREAMBLE

This protocol is a user-mandated, non-negotiable directive established to eliminate the possibility of regression, silent errors, and workflow violations. Its purpose is to enforce a state of constant project integrity. Failure to adhere to this protocol is considered a critical operational failure, leading to a loss of project integrity, the silent introduction of bugs, and a breach of trust with the user. It negates the purpose of having an AI assistant and is the highest form of "hack work" (халтура).

## 2. TRIGGER CONDITION

This protocol is triggered **IMMEDIATELY** after any operation that modifies one or more files in the project repository. This includes, but is not limited to:
- Tool calls such as `replace`, `write_file`, `delete_file`.
- Any modification to any file, regardless of its type or purpose: `.ts`, `.tsx`, `.js`, `.mjs`, `.json`, configuration files, data files, etc.

There are **NO EXCEPTIONS**.

## 3. MANDATORY VERIFICATION SEQUENCE

The following commands **MUST** be executed in this exact order. The sequence must halt immediately if any command fails (exits with a non-zero status code).

1.  **Run All Checks:**
    ```bash
    make check-all
    ```

## 4. PROTOCOL OUTCOME

-   **ON FAILURE:** If any command in the sequence fails, the modification task is considered a **FAILED OPERATION**. All other activities must cease. The immediate and sole priority becomes fixing the error reported by the failed command. No commits can be made, and no task completion summaries (e.g., "Task complete") can be issued until the entire verification sequence is re-run from the beginning and passes completely.

-   **ON SUCCESS:** Only after all commands in the sequence (`eslint`, `tsc`, `vitest`, `next build`, and `storybook build`) have executed and passed successfully can the modification task be considered complete. Only then is it permissible to proceed to the next step, such as creating a commit or confirming task completion to the user.

**This protocol is now an immutable part of the operational logic for this project.**
